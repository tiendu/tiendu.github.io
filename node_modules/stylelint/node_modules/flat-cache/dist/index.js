import c from"fs";import p from"path";import{CacheableMemory as _}from"cacheable";import{parse as d,stringify as y}from"flatted";import{Hookified as g}from"hookified";var b=(a=>(a.SAVE="save",a.LOAD="load",a.DELETE="delete",a.CLEAR="clear",a.DESTROY="destroy",a.ERROR="error",a.EXPIRED="expired",a))(b||{}),l=class extends g{_cache=new _;_cacheDir=".cache";_cacheId="cache1";_persistInterval=0;_persistTimer;_changesSinceLastSave=!1;_parse=d;_stringify=y;constructor(e){super(),e&&(this._cache=new _({ttl:e.ttl,useClone:e.useClone,lruSize:e.lruSize,checkInterval:e.expirationInterval})),e?.cacheDir&&(this._cacheDir=e.cacheDir),e?.cacheId&&(this._cacheId=e.cacheId),e?.persistInterval&&(this._persistInterval=e.persistInterval,this.startAutoPersist()),e?.deserialize&&(this._parse=e.deserialize),e?.serialize&&(this._stringify=e.serialize)}get cache(){return this._cache}get cacheDir(){return this._cacheDir}set cacheDir(e){this._cacheDir=e}get cacheId(){return this._cacheId}set cacheId(e){this._cacheId=e}get changesSinceLastSave(){return this._changesSinceLastSave}get persistInterval(){return this._persistInterval}set persistInterval(e){this._persistInterval=e}load(e,i){try{let s=p.resolve(`${i??this._cacheDir}/${e??this._cacheId}`);this.loadFile(s),this.emit("load")}catch(s){this.emit("error",s)}}loadFile(e){if(c.existsSync(e)){let i=c.readFileSync(e,"utf8"),s=this._parse(i);if(Array.isArray(s))for(let t of s)t&&typeof t=="object"&&"key"in t&&(t.expires?this._cache.set(t.key,t.value,{expire:t.expires}):t.timestamp?this._cache.set(t.key,t.value,{expire:t.timestamp}):this._cache.set(t.key,t.value));else for(let t of Object.keys(s)){let r=s[t];r&&typeof r=="object"&&"key"in r?this._cache.set(r.key,r.value,{expire:r.expires}):r&&typeof r=="object"&&r.timestamp?this._cache.set(t,r,{expire:r.timestamp}):this._cache.set(t,r)}this._changesSinceLastSave=!0}}loadFileStream(e,i,s,t){if(c.existsSync(e)){let v=c.statSync(e).size,a=0,f="",u=c.createReadStream(e,{encoding:"utf8"});u.on("data",h=>{a+=h.length,f+=h,i(a,v)}),u.on("end",()=>{let h=this._parse(f);for(let o of Object.keys(h))this._cache.set(h[o].key,h[o].value,{expire:h[o].expires});this._changesSinceLastSave=!0,s()}),u.on("error",h=>{this.emit("error",h),t&&t(h)})}else{let r=new Error(`Cache file ${e} does not exist`);this.emit("error",r),t&&t(r)}}all(){let e={},i=[...this._cache.items];for(let s of i)e[s.key]=s.value;return e}get items(){return[...this._cache.items]}get cacheFilePath(){return p.resolve(`${this._cacheDir}/${this._cacheId}`)}get cacheDirPath(){return p.resolve(this._cacheDir)}keys(){return[...this._cache.keys]}setKey(e,i,s){this.set(e,i,s)}set(e,i,s){this._cache.set(e,i,s),this._changesSinceLastSave=!0}removeKey(e){this.delete(e)}delete(e){this._cache.delete(e),this._changesSinceLastSave=!0,this.emit("delete",e)}getKey(e){return this.get(e)}get(e){return this._cache.get(e)}clear(){try{this._cache.clear(),this._changesSinceLastSave=!0,this.save(),this.emit("clear")}catch(e){this.emit("error",e)}}save(e=!1){try{if(this._changesSinceLastSave||e){let i=this.cacheFilePath,s=[...this._cache.items],t=this._stringify(s);c.existsSync(this._cacheDir)||c.mkdirSync(this._cacheDir,{recursive:!0}),c.writeFileSync(i,t),this._changesSinceLastSave=!1,this.emit("save")}}catch(i){this.emit("error",i)}}removeCacheFile(){try{if(c.existsSync(this.cacheFilePath))return c.rmSync(this.cacheFilePath),!0}catch(e){this.emit("error",e)}return!1}destroy(e=!1){try{this._cache.clear(),this.stopAutoPersist(),e?c.rmSync(this.cacheDirPath,{recursive:!0,force:!0}):c.rmSync(this.cacheFilePath,{recursive:!0,force:!0}),this._changesSinceLastSave=!1,this.emit("destroy")}catch(i){this.emit("error",i)}}startAutoPersist(){this._persistInterval>0&&(this._persistTimer&&(clearInterval(this._persistTimer),this._persistTimer=void 0),this._persistTimer=setInterval(()=>{this.save()},this._persistInterval))}stopAutoPersist(){this._persistTimer&&(clearInterval(this._persistTimer),this._persistTimer=void 0)}},m=class{static create=S;static createFromFile=I;static clearCacheById=R;static clearAll=x};function S(n){let e=new l(n);return e.load(),e}function I(n,e){let i=new l(e);return i.loadFile(n),i}function R(n,e){new l({cacheId:n,cacheDir:e}).destroy()}function x(n){c.rmSync(n??".cache",{recursive:!0,force:!0})}export{l as FlatCache,b as FlatCacheEvents,x as clearAll,R as clearCacheById,S as create,I as createFromFile,m as default};
