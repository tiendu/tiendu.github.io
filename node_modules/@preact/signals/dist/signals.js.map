{"version":3,"file":"signals.js","sources":["../src/index.ts"],"sourcesContent":["import { options, Component, isValidElement, Fragment } from \"preact\";\nimport { useRef, useMemo, useEffect, useState } from \"preact/hooks\";\nimport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n\tSignalOptions,\n\tEffectOptions,\n} from \"@preact/signals-core\";\nimport {\n\tVNode,\n\tOptionsTypes,\n\tHookFn,\n\tEffect,\n\tPropertyUpdater,\n\tAugmentedComponent,\n\tAugmentedElement as Element,\n} from \"./internal\";\n\nexport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n};\n\nconst HAS_PENDING_UPDATE = 1 << 0;\nconst HAS_HOOK_STATE = 1 << 1;\nconst HAS_COMPUTEDS = 1 << 2;\n\nlet oldNotify: (this: Effect) => void,\n\teffectsQueue: Array<Effect> = [],\n\tdomQueue: Array<Effect> = [];\n\n// Capture the original `Effect.prototype._notify` method so that we can install\n// custom `._notify`s for each different use-case but still call the original\n// implementation in the end. Dispose the temporary effect immediately afterwards.\neffect(function (this: Effect) {\n\toldNotify = this._notify;\n})();\n\n// Install a Preact options hook\nfunction hook<T extends OptionsTypes>(hookName: T, hookFn: HookFn<T>) {\n\t// @ts-ignore-next-line private options hooks usage\n\toptions[hookName] = hookFn.bind(null, options[hookName] || (() => {}));\n}\n\nlet currentComponent: AugmentedComponent | undefined;\nlet finishUpdate: (() => void) | undefined;\n\nfunction setCurrentUpdater(updater?: Effect) {\n\t// end tracking for the current update:\n\tif (finishUpdate) finishUpdate();\n\t// start tracking the new update:\n\tfinishUpdate = updater && updater._start();\n}\n\nfunction createUpdater(update: () => void) {\n\tlet updater!: Effect;\n\teffect(function (this: Effect) {\n\t\tupdater = this;\n\t});\n\tupdater._callback = update;\n\treturn updater;\n}\n\n/** @todo This may be needed for complex prop value detection. */\n// function isSignalValue(value: any): value is Signal {\n// \tif (typeof value !== \"object\" || value == null) return false;\n// \tif (value instanceof Signal) return true;\n// \t// @TODO: uncomment this when we land Reactive (ideally behind a brand check)\n// \t// for (let i in value) if (value[i] instanceof Signal) return true;\n// \treturn false;\n// }\n\n/**\n * A wrapper component that renders a Signal directly as a Text node.\n * @todo: in Preact 11, just decorate Signal with `type:null`\n */\nfunction SignalValue(this: AugmentedComponent, { data }: { data: Signal }) {\n\t// hasComputeds.add(this);\n\n\t// Store the props.data signal in another signal so that\n\t// passing a new signal reference re-runs the text computed:\n\tconst currentSignal = useSignal(data);\n\tcurrentSignal.value = data;\n\n\tconst [isText, s] = useMemo(() => {\n\t\tlet self = this;\n\t\t// mark the parent component as having computeds so it gets optimized\n\t\tlet v = this.__v;\n\t\twhile ((v = v.__!)) {\n\t\t\tif (v.__c) {\n\t\t\t\tv.__c._updateFlags |= HAS_COMPUTEDS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst wrappedSignal = computed(() => {\n\t\t\tlet s = currentSignal.value.value;\n\t\t\treturn s === 0 ? 0 : s === true ? \"\" : s || \"\";\n\t\t});\n\n\t\tconst isText = computed(\n\t\t\t() =>\n\t\t\t\t!Array.isArray(wrappedSignal.value) &&\n\t\t\t\t!isValidElement(wrappedSignal.value)\n\t\t);\n\t\t// Update text nodes directly without rerendering when the new value\n\t\t// is also text.\n\t\tconst dispose = effect(function (this: Effect) {\n\t\t\tthis._notify = notifyDomUpdates;\n\n\t\t\t// Subscribe to wrappedSignal updates only when its values are text...\n\t\t\tif (isText.value) {\n\t\t\t\t// ...but regardless of `self.base`'s current value, as it can be\n\t\t\t\t// undefined before mounting or a non-text node. In both of those cases\n\t\t\t\t// the update gets handled by a full rerender.\n\t\t\t\tconst value = wrappedSignal.value;\n\t\t\t\tif (self.__v && self.__v.__e && self.__v.__e.nodeType === 3) {\n\t\t\t\t\t(self.__v.__e as Text).data = value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Piggyback this._updater's disposal to ensure that the text updater effect\n\t\t// above also gets disposed on unmount.\n\t\tconst oldDispose = this._updater!._dispose;\n\t\tthis._updater!._dispose = function () {\n\t\t\tdispose();\n\t\t\toldDispose.call(this);\n\t\t};\n\n\t\treturn [isText, wrappedSignal];\n\t}, []);\n\n\t// Rerender the component whenever `data.value` changes from a VNode\n\t// to another VNode, from text to a VNode, or from a VNode to text.\n\t// That is, everything else except text-to-text updates.\n\t//\n\t// This also ensures that the backing DOM node types gets updated to\n\t// text nodes and back when needed.\n\t//\n\t// For text-to-text updates, `.peek()` is used to skip full rerenders,\n\t// leaving them to the optimized path above.\n\treturn isText.value ? s.peek() : s.value;\n}\n\nSignalValue.displayName = \"ReactiveTextNode\";\n\nObject.defineProperties(Signal.prototype, {\n\tconstructor: { configurable: true, value: undefined },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\t// Setting a VNode's _depth to 1 forces Preact to clone it before modifying:\n\t// https://github.com/preactjs/preact/blob/d7a433ee8463a7dc23a05111bb47de9ec729ad4d/src/diff/children.js#L77\n\t// @todo remove this for Preact 11\n\t__b: { configurable: true, value: 1 },\n});\n\n/** Inject low-level property/attribute bindings for Signals into Preact's diff */\nhook(OptionsTypes.DIFF, (old, vnode) => {\n\tif (\n\t\ttypeof vnode.type === \"function\" &&\n\t\ttypeof window !== \"undefined\" &&\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__\n\t) {\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__.exitComponent();\n\t}\n\n\tif (typeof vnode.type === \"string\") {\n\t\tlet signalProps: Record<string, any> | undefined;\n\n\t\tlet props = vnode.props;\n\t\tfor (let i in props) {\n\t\t\tif (i === \"children\") continue;\n\n\t\t\tlet value = props[i];\n\t\t\tif (value instanceof Signal) {\n\t\t\t\tif (!signalProps) vnode.__np = signalProps = {};\n\t\t\t\tsignalProps[i] = value;\n\t\t\t\tprops[i] = value.peek();\n\t\t\t}\n\t\t}\n\t}\n\n\told(vnode);\n});\n\n/** Set up Updater before rendering a component */\nhook(OptionsTypes.RENDER, (old, vnode) => {\n\tif (\n\t\ttypeof vnode.type === \"function\" &&\n\t\ttypeof window !== \"undefined\" &&\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__\n\t) {\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__.enterComponent(vnode);\n\t}\n\n\t// Ignore the Fragment inserted by preact.createElement().\n\tif (vnode.type !== Fragment) {\n\t\tsetCurrentUpdater();\n\n\t\tlet updater;\n\n\t\tlet component = vnode.__c;\n\t\tif (component) {\n\t\t\tcomponent._updateFlags &= ~HAS_PENDING_UPDATE;\n\n\t\t\tupdater = component._updater;\n\t\t\tif (updater === undefined) {\n\t\t\t\tcomponent._updater = updater = createUpdater(() => {\n\t\t\t\t\tcomponent._updateFlags |= HAS_PENDING_UPDATE;\n\t\t\t\t\tcomponent.setState({});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tcurrentComponent = component;\n\t\tsetCurrentUpdater(updater);\n\t}\n\n\told(vnode);\n});\n\n/** Finish current updater if a component errors */\nhook(OptionsTypes.CATCH_ERROR, (old, error, vnode, oldVNode) => {\n\tif (typeof window !== \"undefined\" && window.__PREACT_SIGNALS_DEVTOOLS__) {\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__.exitComponent();\n\t}\n\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\told(error, vnode, oldVNode);\n});\n\n/** Finish current updater after rendering any VNode */\nhook(OptionsTypes.DIFFED, (old, vnode) => {\n\tif (\n\t\ttypeof vnode.type === \"function\" &&\n\t\ttypeof window !== \"undefined\" &&\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__\n\t) {\n\t\twindow.__PREACT_SIGNALS_DEVTOOLS__.exitComponent();\n\t}\n\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\n\tlet dom: Element;\n\n\t// vnode._dom is undefined during string rendering,\n\t// so we use this to skip prop subscriptions during SSR.\n\tif (typeof vnode.type === \"string\" && (dom = vnode.__e as Element)) {\n\t\tlet props = vnode.__np;\n\t\tlet renderedProps = vnode.props;\n\t\tif (props) {\n\t\t\tlet updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater !== undefined && !(prop in props)) {\n\t\t\t\t\t\tupdater._dispose();\n\t\t\t\t\t\t// @todo we could just always invoke _dispose() here\n\t\t\t\t\t\tupdaters[prop] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tupdaters = {};\n\t\t\t\tdom._updaters = updaters;\n\t\t\t}\n\t\t\tfor (let prop in props) {\n\t\t\t\tlet updater = updaters[prop];\n\t\t\t\tlet signal = props[prop];\n\t\t\t\tif (updater === undefined) {\n\t\t\t\t\tupdater = createPropUpdater(dom, prop, signal, renderedProps);\n\t\t\t\t\tupdaters[prop] = updater;\n\t\t\t\t} else {\n\t\t\t\t\tupdater._update(signal, renderedProps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\nfunction createPropUpdater(\n\tdom: Element,\n\tprop: string,\n\tpropSignal: Signal,\n\tprops: Record<string, any>\n): PropertyUpdater {\n\tconst setAsProperty =\n\t\tprop in dom &&\n\t\t// SVG elements need to go through `setAttribute` because they\n\t\t// expect things like SVGAnimatedTransformList instead of strings.\n\t\t// @ts-ignore\n\t\tdom.ownerSVGElement === undefined;\n\n\tconst changeSignal = signal(propSignal);\n\treturn {\n\t\t_update: (newSignal: Signal, newProps: typeof props) => {\n\t\t\tchangeSignal.value = newSignal;\n\t\t\tprops = newProps;\n\t\t},\n\t\t_dispose: effect(function (this: Effect) {\n\t\t\tthis._notify = notifyDomUpdates;\n\t\t\tconst value = changeSignal.value.value;\n\t\t\t// If Preact just rendered this value, don't render it again:\n\t\t\tif (props[prop] === value) return;\n\t\t\tprops[prop] = value;\n\t\t\tif (setAsProperty) {\n\t\t\t\t// @ts-ignore-next-line silly\n\t\t\t\tdom[prop] = value;\n\t\t\t} else if (value) {\n\t\t\t\tdom.setAttribute(prop, value);\n\t\t\t} else {\n\t\t\t\tdom.removeAttribute(prop);\n\t\t\t}\n\t\t}),\n\t};\n}\n\n/** Unsubscribe from Signals when unmounting components/vnodes */\nhook(OptionsTypes.UNMOUNT, (old, vnode: VNode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet dom = vnode.__e as Element | undefined;\n\t\t// vnode._dom is undefined during string rendering\n\t\tif (dom) {\n\t\t\tconst updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tdom._updaters = undefined;\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater) updater._dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlet component = vnode.__c;\n\t\tif (component) {\n\t\t\tconst updater = component._updater;\n\t\t\tif (updater) {\n\t\t\t\tcomponent._updater = undefined;\n\t\t\t\tupdater._dispose();\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\n/** Mark components that use hook state so we can skip sCU optimization. */\nhook(OptionsTypes.HOOK, (old, component, index, type) => {\n\tif (type < 3 || type === 9)\n\t\t(component as AugmentedComponent)._updateFlags |= HAS_HOOK_STATE;\n\told(component, index, type);\n});\n\n/**\n * Auto-memoize components that use Signals/Computeds.\n * Note: Does _not_ optimize components that use hook/class state.\n */\nComponent.prototype.shouldComponentUpdate = function (\n\tthis: AugmentedComponent,\n\tprops,\n\tstate\n) {\n\t// @todo: Once preactjs/preact#3671 lands, this could just use `currentUpdater`:\n\tconst updater = this._updater;\n\tconst hasSignals = updater && updater._sources !== undefined;\n\n\t// If this is a component using state, rerender\n\t// @ts-ignore\n\tfor (let i in state) return true;\n\n\tif (this.__f || (typeof this.u == \"boolean\" && this.u === true)) {\n\t\tconst hasHooksState = this._updateFlags & HAS_HOOK_STATE;\n\t\t// if this component used no signals or computeds and no hooks state, update:\n\t\tif (!hasSignals && !hasHooksState && !(this._updateFlags & HAS_COMPUTEDS))\n\t\t\treturn true;\n\n\t\t// if there is a pending re-render triggered from Signals,\n\t\t// or if there is hooks state, update:\n\t\tif (this._updateFlags & HAS_PENDING_UPDATE) return true;\n\t} else {\n\t\t// if this component used no signals or computeds, update:\n\t\tif (!hasSignals && !(this._updateFlags & HAS_COMPUTEDS)) return true;\n\n\t\t// if there is a pending re-render triggered from Signals,\n\t\t// or if there is hooks state, update:\n\t\tif (this._updateFlags & (HAS_PENDING_UPDATE | HAS_HOOK_STATE)) return true;\n\t}\n\n\t// if any non-Signal props changed, update:\n\tfor (let i in props) {\n\t\tif (i !== \"__source\" && props[i] !== this.props[i]) return true;\n\t}\n\tfor (let i in this.props) if (!(i in props)) return true;\n\n\t// this is a purely Signal-driven component, don't update:\n\treturn false;\n};\n\nexport function useSignal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T, options?: SignalOptions<T>) {\n\treturn useState(() =>\n\t\tsignal<T | undefined>(value, options as SignalOptions)\n\t)[0];\n}\n\nexport function useComputed<T>(\n\tcompute: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\tconst [$fn, $computed] = useMemo(() => {\n\t\tconst $fn = signal(compute);\n\t\treturn [$fn, computed(() => $fn.value(), options)] as const;\n\t}, []);\n\n\t(currentComponent as AugmentedComponent)._updateFlags |= HAS_COMPUTEDS;\n\t$fn.value = compute;\n\treturn $computed;\n}\n\nfunction safeRaf(callback: () => void) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tcancelAnimationFrame(raf);\n\t\tcallback();\n\t};\n\n\tconst timeout = setTimeout(done, 35);\n\tconst raf = requestAnimationFrame(done);\n}\n\nconst deferEffects =\n\ttypeof requestAnimationFrame === \"undefined\" ? setTimeout : safeRaf;\n\nconst deferDomUpdates = (cb: any) => {\n\tqueueMicrotask(() => {\n\t\tqueueMicrotask(cb);\n\t});\n};\n\nfunction flushEffects() {\n\tbatch(() => {\n\t\tlet inst: Effect | undefined;\n\t\twhile ((inst = effectsQueue.shift())) {\n\t\t\toldNotify.call(inst);\n\t\t}\n\t});\n}\n\nfunction notifyEffects(this: Effect) {\n\tif (effectsQueue.push(this) === 1) {\n\t\t(options.requestAnimationFrame || deferEffects)(flushEffects);\n\t}\n}\n\nfunction flushDomUpdates() {\n\tbatch(() => {\n\t\tlet inst: Effect | undefined;\n\t\twhile ((inst = domQueue.shift())) {\n\t\t\toldNotify.call(inst);\n\t\t}\n\t});\n}\n\nfunction notifyDomUpdates(this: Effect) {\n\tif (domQueue.push(this) === 1) {\n\t\t(options.requestAnimationFrame || deferDomUpdates)(flushDomUpdates);\n\t}\n}\n\nexport function useSignalEffect(\n\tcb: () => void | (() => void),\n\toptions?: EffectOptions\n) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(function (this: Effect) {\n\t\t\tthis._notify = notifyEffects;\n\t\t\treturn callback.current();\n\t\t}, options);\n\t}, []);\n}\n\n/**\n * @todo Determine which Reactive implementation we'll be using.\n * @internal\n */\n// export function useReactive<T extends object>(value: T): Reactive<T> {\n// \treturn useMemo(() => reactive<T>(value), []);\n// }\n\n/**\n * @internal\n * Update a Reactive's using the properties of an object or other Reactive.\n * Also works for Signals.\n * @example\n *   // Update a Reactive with Object.assign()-like syntax:\n *   const r = reactive({ name: \"Alice\" });\n *   update(r, { name: \"Bob\" });\n *   update(r, { age: 42 }); // property 'age' does not exist in type '{ name?: string }'\n *   update(r, 2); // '2' has no properties in common with '{ name?: string }'\n *   console.log(r.name.value); // \"Bob\"\n *\n * @example\n *   // Update a Reactive with the properties of another Reactive:\n *   const A = reactive({ name: \"Alice\" });\n *   const B = reactive({ name: \"Bob\", age: 42 });\n *   update(A, B);\n *   console.log(`${A.name} is ${A.age}`); // \"Bob is 42\"\n *\n * @example\n *   // Update a signal with assign()-like syntax:\n *   const s = signal(42);\n *   update(s, \"hi\"); // Argument type 'string' not assignable to type 'number'\n *   update(s, {}); // Argument type '{}' not assignable to type 'number'\n *   update(s, 43);\n *   console.log(s.value); // 43\n *\n * @param obj The Reactive or Signal to be updated\n * @param update The value, Signal, object or Reactive to update `obj` to match\n * @param overwrite If `true`, any properties `obj` missing from `update` are set to `undefined`\n */\n/*\nexport function update<T extends SignalOrReactive>(\n\tobj: T,\n\tupdate: Partial<Unwrap<T>>,\n\toverwrite = false\n) {\n\tif (obj instanceof Signal) {\n\t\tobj.value = peekValue(update);\n\t} else {\n\t\tfor (let i in update) {\n\t\t\tif (i in obj) {\n\t\t\t\tobj[i].value = peekValue(update[i]);\n\t\t\t} else {\n\t\t\t\tlet sig = signal(peekValue(update[i]));\n\t\t\t\tsig[KEY] = i;\n\t\t\t\tobj[i] = sig;\n\t\t\t}\n\t\t}\n\t\tif (overwrite) {\n\t\t\tfor (let i in obj) {\n\t\t\t\tif (!(i in update)) {\n\t\t\t\t\tobj[i].value = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n*/\n"],"names":["oldNotify","currentComponent","finishUpdate","effectsQueue","domQueue","effect","this","_notify","hook","hookName","hookFn","options","bind","setCurrentUpdater","updater","_start","SignalValue","_ref","_this","data","currentSignal","useSignal","value","_useMemo","useMemo","self","v","__v","__","__c","_updateFlags","wrappedSignal","computed","s","isText","Array","isArray","isValidElement","dispose","notifyDomUpdates","__e","nodeType","oldDispose","_updater","_dispose","call","peek","displayName","Object","defineProperties","Signal","prototype","constructor","configurable","undefined","type","props","get","__b","old","vnode","window","__PREACT_SIGNALS_DEVTOOLS__","exitComponent","signalProps","i","__np","enterComponent","Fragment","component","update","_callback","setState","createUpdater","error","oldVNode","dom","renderedProps","updaters","_updaters","prop","signal","createPropUpdater","_update","propSignal","setAsProperty","ownerSVGElement","changeSignal","newSignal","newProps","setAttribute","removeAttribute","index","Component","shouldComponentUpdate","state","hasSignals","_sources","__f","u","hasHooksState","HAS_PENDING_UPDATE","useState","deferEffects","requestAnimationFrame","setTimeout","callback","done","clearTimeout","timeout","cancelAnimationFrame","raf","deferDomUpdates","cb","queueMicrotask","flushEffects","batch","inst","shift","notifyEffects","push","flushDomUpdates","exports","signalsCore","untracked","useComputed","compute","_useMemo2","$fn","$computed","useSignalEffect","useRef","current","useEffect"],"mappings":"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"}